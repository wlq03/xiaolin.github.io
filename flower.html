<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>饱满粒子花束</title>
    <style>
        body { margin: 0; overflow: hidden; background: #0f0f1e; }
        canvas { display: block; }
    </style>
</head>
<body>
    <canvas id="flowerCanvas"></canvas>

    <script>
        const canvas = document.getElementById('flowerCanvas');
        const ctx = canvas.getContext('2d');
        let scale = 1;
        let offsetX = 0;
        let offsetY = 0;
        let lastTouchX, lastTouchY;
        let isDragging = false;

        // 适配屏幕尺寸
        function resizeCanvas() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
        }
        window.addEventListener('resize', resizeCanvas);
        resizeCanvas();

        // 高清屏幕适配（解决手机模糊问题）
        function setupHiDPI() {
            const dpr = window.devicePixelRatio || 1;
            const rect = canvas.getBoundingClientRect();
            canvas.width = rect.width * dpr;
            canvas.height = rect.height * dpr;
            ctx.scale(dpr, dpr);
        }
        setupHiDPI();
        window.addEventListener('resize', setupHiDPI);

        // 设备检测（手机端优化粒子数量）
        const isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
        const particleMultiplier = isMobile ? 0.7 : 1.0; // 手机端减少30%粒子，保证流畅

        // 配色方案（与原Python代码完全一致）
        const colors = {
            bg: [15, 15, 30],
            rose: [
                [210, 40, 80],    // ROSE_DARK
                [225, 60, 100],   // ROSE_DARK_MID
                [240, 80, 120],   // ROSE_MID
                [245, 100, 140],  // ROSE_LIGHT_MID
                [250, 120, 160]   // ROSE_LIGHT
            ],
            pink: [
                [220, 90, 140],   // PINK_DARK
                [230, 110, 155],  // PINK_DARK_MID
                [240, 130, 170],  // PINK_MID
                [248, 150, 185],  // PINK_LIGHT_MID
                [255, 170, 200]   // PINK_LIGHT
            ],
            yellow: [
                [255, 200, 60],   // YELLOW_CENTER
                [255, 220, 90]    // YELLOW_LIGHT
            ],
            orange: [
                [255, 150, 70],   // ORANGE_CENTER
                [255, 170, 90]    // ORANGE_LIGHT
            ],
            green: {
                stem: [25, 120, 50],
                leaf: [45, 150, 70],
                light: [65, 170, 90]
            },
            ribbon: {
                dark: [250, 100, 150],
                light: [255, 140, 180]
            }
        };

        // 粒子类（修复手机端动画问题）
        class Particle {
            constructor(x, y, color, size, alpha = 255, glow = 0) {
                this.x = x;
                this.y = y;
                this.baseX = x;
                this.baseY = y;
                this.originalColor = [...color];
                this.color = [...color];
                this.size = size;
                this.alpha = alpha;
                this.glow = glow;
                this.angle = Math.random() * Math.PI * 2;
                this.speed = 0.008 + Math.random() * 0.012;
                this.amp = 0.3 + Math.random() * 0.7;
                this.pulse = Math.random() * Math.PI * 2;
            }

            update(time) {
                // 手机端时间因子，确保动画节奏一致
                const timeFactor = isMobile ? 0.7 : 1.0;
                // 自然晃动轨迹（适配手机浏览器）
                this.x = this.baseX + Math.sin(time * timeFactor + this.angle) * this.amp;
                this.y = this.baseY + Math.cos(time * timeFactor + this.angle * 1.1) * this.amp * 0.7;
                
                // 柔和呼吸光效（修复手机端闪烁问题）
                const pulse = Math.sin(time * timeFactor + this.pulse) * 0.04 + 1.0;
                this.color[0] = Math.min(255, Math.floor(this.originalColor[0] * pulse));
                this.color[1] = Math.min(255, Math.floor(this.originalColor[1] * pulse));
                this.color[2] = Math.min(255, Math.floor(this.originalColor[2] * pulse));
            }

            draw() {
                // 绘制光泽层（增强手机端视觉效果）
                if (this.glow > 0) {
                    const glowSize = this.size * (1.4 + this.glow) * scale;
                    ctx.beginPath();
                    ctx.arc(
                        this.x * scale + offsetX,
                        this.y * scale + offsetY,
                        glowSize,
                        0,
                        Math.PI * 2
                    );
                    const glowR = Math.min(255, this.color[0] + 25);
                    const glowG = Math.min(255, this.color[1] + 10);
                    const glowB = Math.min(255, this.color[2]);
                    ctx.fillStyle = `rgba(${glowR}, ${glowG}, ${glowB}, ${this.alpha * 0.15 / 255})`;
                    ctx.fill();
                }

                // 绘制粒子主体（高清渲染）
                const drawSize = this.size * scale;
                ctx.beginPath();
                ctx.arc(
                    this.x * scale + offsetX,
                    this.y * scale + offsetY,
                    drawSize,
                    0,
                    Math.PI * 2
                );
                ctx.fillStyle = `rgba(${this.color[0]}, ${this.color[1]}, ${this.color[2]}, ${this.alpha / 255})`;
                ctx.fill();
            }
        }

        // 生成花朵（适配手机端粒子数量）
        function createFlower(x, y, radius, colorScheme) {
            const particles = [];
            const [petalColors, centerColors] = colorScheme;

            // 最外层花瓣
            for (let i = 0; i < Math.floor(900 * particleMultiplier); i++) {
                let angle = Math.random() * Math.PI * 2;
                angle += Math.sin(angle * 4) * 0.3;
                const dist = radius * 0.7 + Math.random() * radius * 0.3;
                const px = x + dist * Math.cos(angle);
                const py = y + dist * Math.sin(angle);
                const ratio = dist / radius;

                let color;
                if (ratio > 0.9) color = petalColors[4];
                else if (ratio > 0.8) color = petalColors[Math.random() > 0.5 ? 3 : 4];
                else color = petalColors[3];

                const size = 2.5 + Math.random() * 1.3;
                const alpha = 220 - Math.floor(ratio * 30);
                const glow = ratio > 0.85 ? 0.5 : 0.2;
                particles.push(new Particle(px, py, color, size, alpha, glow));
            }

            // 中外层花瓣
            for (let i = 0; i < Math.floor(800 * particleMultiplier); i++) {
                let angle = Math.random() * Math.PI * 2;
                angle += Math.sin(angle * 5) * 0.2;
                const dist = radius * 0.5 + Math.random() * radius * 0.2;
                const px = x + dist * Math.cos(angle);
                const py = y + dist * Math.sin(angle);
                const ratio = dist / radius;

                let color;
                if (ratio > 0.6) color = petalColors[Math.random() > 0.5 ? 2 : 3];
                else color = petalColors[Math.random() > 0.5 ? 1 : 2];

                const size = 2.0 + Math.random() * 1.0;
                particles.push(new Particle(px, py, color, size, 230));
            }

            // 内层花瓣
            for (let i = 0; i < Math.floor(700 * particleMultiplier); i++) {
                const angle = Math.random() * Math.PI * 2;
                const dist = radius * 0.2 + Math.random() * radius * 0.3;
                const px = x + dist * Math.cos(angle);
                const py = y + dist * Math.sin(angle);
                const ratio = dist / radius;

                const color = ratio < 0.3 ? petalColors[0] : petalColors[Math.random() > 0.5 ? 0 : 1];
                const size = 1.8 + Math.random() * 0.7;
                particles.push(new Particle(px, py, color, size, 240));
            }

            // 花蕊
            for (let i = 0; i < Math.floor(400 * particleMultiplier); i++) {
                const angle = Math.random() * Math.PI * 2;
                const dist = Math.random() * radius * 0.25;
                const px = x + dist * Math.cos(angle);
                const py = y + dist * Math.sin(angle);
                const ratio = dist / radius;

                const color = ratio < 0.3 ? centerColors[0] : centerColors[Math.random() > 0.5 ? 0 : 1];
                const size = 2.2 + Math.random() * 1.0 - ratio * 1.0;
                const glow = 0.7 - ratio * 0.5;
                particles.push(new Particle(px, py, color, size, 255, glow));
            }

            return particles;
        }

        // 生成花茎和叶子（适配手机端）
        function createStemLeaf(x, y, length) {
            const particles = [];
            const curveDir = Math.random() > 0.5 ? -1 : 1;

            // 花茎
            for (let i = 0; i < Math.floor(450 * particleMultiplier); i++) {
                const sy = y + Math.random() * length;
                const curve = Math.sin(sy * 0.015) * 4 * curveDir;
                const sx = x + curve + (Math.random() * 2.4 - 1.2);
                const ratio = sy / (y + length);
                const size = 1.3 + ratio * 0.7;
                
                const g = Math.floor(colors.green.stem[1] + (colors.green.leaf[1] - colors.green.stem[1]) * ratio * 0.3);
                const color = [25, g, 50];
                particles.push(new Particle(sx, sy, color, size, 230));
            }

            // 叶子
            const leafPositions = [
                [x - 40, y + length * 0.2, 40, -1],
                [x + 45, y + length * 0.5, 45, 1],
                [x - 30, y + length * 0.7, 35, -1]
            ];

            leafPositions.forEach(([lx, ly, size, dir]) => {
                // 叶脉
                for (let i = 0; i < Math.floor(60 * particleMultiplier); i++) {
                    const nx = lx + dir * Math.random() * size * 0.7;
                    const ny = ly - Math.random() * size * 0.8;
                    particles.push(new Particle(nx, ny, colors.green.stem, 1.3, 240));
                }

                // 叶片
                for (let i = 0; i < Math.floor(350 * particleMultiplier); i++) {
                    const angle = Math.random() * Math.PI / 1.4;
                    let dist = Math.random() * size;
                    
                    if (dist > size * 0.75) {
                        if (Math.random() > 0.6) continue;
                        dist *= 0.9 + Math.random() * 0.2;
                    }
                    
                    const px = lx + dir * dist * Math.cos(angle);
                    const py = ly - dist * Math.sin(angle);
                    const ratio = dist / size;
                    
                    const g = Math.floor(colors.green.leaf[1] + (colors.green.light[1] - colors.green.leaf[1]) * ratio);
                    const color = [40, g, 60];
                    const leafSize = 1.6 + (1 - ratio) * 0.9;
                    particles.push(new Particle(px, py, color, leafSize, 210 + Math.floor(ratio * 40)));
                }
            });

            return particles;
        }

        // 生成丝带（适配手机端）
        function createRibbon(x, y) {
            const particles = [];

            // 丝带主体
            for (let i = 0; i < Math.floor(350 * particleMultiplier); i++) {
                const wave1 = Math.sin(i * 0.06) * 14;
                const wave2 = Math.cos(i * 0.12) * 6;
                const x1 = x - 16 + wave1 + wave2 + (Math.random() * 3 - 1.5);
                const x2 = x + 16 + wave1 - wave2 + (Math.random() * 3 - 1.5);
                const ry = y + i * 1.0 - 45;
                const ratio = i / 350;

                const r = Math.floor(colors.ribbon.dark[0] + (colors.ribbon.light[0] - colors.ribbon.dark[0]) * ratio);
                const g = Math.floor(colors.ribbon.dark[1] + (colors.ribbon.light[1] - colors.ribbon.dark[1]) * ratio);
                const b = Math.floor(colors.ribbon.dark[2] + (colors.ribbon.light[2] - colors.ribbon.dark[2]) * ratio);
                const color = [r, g, b];

                particles.push(new Particle(x1, ry, color, 1.6, 230, 0.2));
                particles.push(new Particle(x2, ry, color, 1.6, 230, 0.2));
            }

            // 蝴蝶结
            const bowCenter = [x, y - 30];
            // 蝴蝶结中心
            for (let i = 0; i < Math.floor(120 * particleMultiplier); i++) {
                const dist = Math.random() * 14;
                const angle = Math.random() * Math.PI * 2;
                const px = bowCenter[0] + dist * Math.cos(angle);
                const py = bowCenter[1] + dist * Math.sin(angle);
                particles.push(new Particle(px, py, colors.ribbon.dark, 2.8, 240, 0.3));
            }
            // 蝴蝶结两侧
            [ -1, 1 ].forEach(side => {
                for (let i = 0; i < Math.floor(150 * particleMultiplier); i++) {
                    const angle = Math.random() * Math.PI / 2 - Math.PI / 4;
                    const dist = 12 + Math.random() * 18;
                    const px = bowCenter[0] + side * dist * Math.cos(angle);
                    const py = bowCenter[1] + dist * Math.sin(angle);
                    particles.push(new Particle(px, py, colors.ribbon.light, 2.2, 230));
                }
            });

            return particles;
        }

        // 组装花束
        function createBouquet() {
            const particles = [];
            const centerX = canvas.width / 2;
            const centerY = canvas.height / 3;

            const flowers = [
                [centerX, centerY + 50, 90, [colors.rose, colors.yellow]],
                [centerX - 100, centerY + 100, 70, [colors.pink, colors.orange]],
                [centerX + 90, centerY + 90, 75, [
                    [colors.rose[1], colors.rose[2], colors.rose[3], colors.pink[2], colors.pink[3]],
                    colors.yellow
                ]],
                [centerX - 60, centerY + 150, 65, [
                    [colors.pink[1], colors.pink[2], colors.pink[3], colors.rose[3], colors.rose[4]],
                    colors.orange
                ]],
                [centerX + 65, centerY + 140, 68, [
                    [colors.rose[0], colors.rose[1], colors.rose[2], colors.pink[1], colors.pink[2]],
                    colors.yellow
                ]]
            ];

            // 添加花朵
            flowers.forEach(([x, y, r, scheme]) => {
                particles.push(...createFlower(x, y, r, scheme));
            });

            // 添加花茎和叶子
            const stemLengths = [420, 380, 400, 350, 360];
            flowers.forEach(([x, y], i) => {
                particles.push(...createStemLeaf(x, y, stemLengths[i]));
            });

            // 添加丝带
            particles.push(...createRibbon(centerX, centerY + 250));

            return particles;
        }

        // 初始化花束
        let particles = createBouquet();
        let time = 0;

        // 动画循环
        function animate() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            ctx.fillStyle = `rgb(${colors.bg[0]}, ${colors.bg[1]}, ${colors.bg[2]})`;
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            time += 0.035;
            
            // 更新所有粒子
            particles.forEach(p => p.update(time));
            
            // 分层绘制（避免遮挡）
            // 1. 花茎和叶子
            particles.forEach(p => {
                if (p.color[1] > 50 && p.color[1] < 200) p.draw();
            });
            // 2. 花朵和丝带
            particles.forEach(p => {
                if (p.color[1] <= 50 || p.color[0] > 200) p.draw();
            });

            requestAnimationFrame(animate);
        }
        animate();

        // 交互：点击重新生成花束
        canvas.addEventListener('click', () => {
            particles = createBouquet();
        });

        // 触摸拖拽交互
        canvas.addEventListener('touchstart', (e) => {
            if (e.touches.length === 1) {
                isDragging = true;
                lastTouchX = e.touches[0].clientX;
                lastTouchY = e.touches[0].clientY;
            }
        });
        canvas.addEventListener('touchmove', (e) => {
            e.preventDefault();
            if (isDragging && e.touches.length === 1) {
                const touchX = e.touches[0].clientX;
                const touchY = e.touches[0].clientY;
                offsetX += touchX - lastTouchX;
                offsetY += touchY - lastTouchY;
                lastTouchX = touchX;
                lastTouchY = touchY;
            }
        });
        canvas.addEventListener('touchend', () => isDragging = false);

        // 双击重置视图
        canvas.addEventListener('dblclick', () => {
            scale = 1;
            offsetX = 0;
            offsetY = 0;
        });
    </script>
</body>
</html>
<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>粒子玫瑰花束</title>
    <style>
        body { margin: 0; overflow: hidden; background: #121220; }
        canvas { display: block; }
        .controls {
            position: fixed;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            padding: 10px 20px;
            background: rgba(0,0,0,0.5);
            border-radius: 30px;
            color: white;
            font-family: sans-serif;
            font-size: 14px;
        }
    </style>
</head>
<body>
    <canvas id="flowerCanvas"></canvas>
    <div class="controls">点击屏幕重新生成 | 双指缩放</div>

    <script>
        // 获取画布并适配手机屏幕
        const canvas = document.getElementById('flowerCanvas');
        const ctx = canvas.getContext('2d');
        let scale = 1;
        let offsetX = 0;
        let offsetY = 0;
        let lastTouchX, lastTouchY;
        let isDragging = false;

        // 适配手机屏幕尺寸
        function resizeCanvas() {
            const { innerWidth, innerHeight } = window;
            canvas.width = innerWidth;
            canvas.height = innerHeight;
        }
        window.addEventListener('resize', resizeCanvas);
        resizeCanvas();

        // 配色方案
        const colors = {
            bg: '#121220',
            rose: [
                [210, 40, 80],   // 深玫瑰红
                [225, 60, 100],  // 中深玫瑰红
                [240, 80, 120],  // 中玫瑰红
                [245, 100, 140], // 中浅玫瑰红
                [250, 120, 160]  // 浅玫瑰红
            ],
            pink: [
                [220, 90, 140],  // 深粉
                [230, 110, 155], // 中深粉
                [240, 130, 170], // 中粉
                [248, 150, 185], // 中浅粉
                [255, 170, 200]  // 浅粉
            ],
            yellow: [
                [255, 200, 60],  // 深黄
                [255, 220, 90]   // 浅黄
            ],
            orange: [
                [255, 150, 70],  // 深橙
                [255, 170, 90]   // 浅橙
            ],
            green: {
                stem: [25, 120, 50],
                leaf: [45, 150, 70],
                light: [65, 170, 90]
            },
            ribbon: {
                dark: [250, 100, 150],
                light: [255, 140, 180]
            }
        };

        // 粒子类
        class Particle {
            constructor(x, y, color, size, alpha = 255, glow = 0) {
                this.x = x;
                this.y = y;
                this.baseX = x;
                this.baseY = y;
                this.originalColor = [...color];
                this.color = [...color];
                this.size = size;
                this.alpha = alpha;
                this.glow = glow;
                this.angle = Math.random() * Math.PI * 2;
                this.speed = 0.008 + Math.random() * 0.012;
                this.amp = 0.3 + Math.random() * 0.7;
                this.pulse = Math.random() * Math.PI * 2;
            }

            update(time) {
                // 自然晃动
                this.x = this.baseX + Math.sin(time + this.angle) * this.amp;
                this.y = this.baseY + Math.cos(time + this.angle * 1.1) * this.amp * 0.7;
                
                // 呼吸光效
                const pulse = Math.sin(time + this.pulse) * 0.04 + 1.0;
                this.color[0] = Math.min(255, Math.floor(this.originalColor[0] * pulse));
                this.color[1] = Math.min(255, Math.floor(this.originalColor[1] * pulse));
                this.color[2] = Math.min(255, Math.floor(this.originalColor[2] * pulse));
            }

            draw(ctx, scale, offsetX, offsetY) {
                const x = this.x * scale + offsetX;
                const y = this.y * scale + offsetY;
                const size = this.size * scale;

                // 绘制光泽
                if (this.glow > 0) {
                    const glowSize = size * (1.4 + this.glow);
                    ctx.beginPath();
                    ctx.arc(x, y, glowSize, 0, Math.PI * 2);
                    ctx.fillStyle = `rgba(${this.color[0] + 25}, ${this.color[1] + 10}, ${this.color[2]}, ${this.alpha * 0.15 / 255})`;
                    ctx.fill();
                }

                // 绘制主体
                ctx.beginPath();
                ctx.arc(x, y, size, 0, Math.PI * 2);
                ctx.fillStyle = `rgba(${this.color[0]}, ${this.color[1]}, ${this.color[2]}, ${this.alpha / 255})`;
                ctx.fill();
            }
        }

        // 生成花朵
        function createFlower(x, y, radius, colorScheme) {
            const particles = [];
            const [petalColors, centerColors] = colorScheme;

            // 最外层花瓣
            for (let i = 0; i < 900; i++) {
                let angle = Math.random() * Math.PI * 2;
                angle += Math.sin(angle * 4) * 0.3;
                const dist = radius * 0.7 + Math.random() * radius * 0.3;
                const px = x + dist * Math.cos(angle);
                const py = y + dist * Math.sin(angle);
                const ratio = dist / radius;

                let color;
                if (ratio > 0.9) {
                    color = petalColors[4];
                } else if (ratio > 0.8) {
                    color = petalColors[Math.random() > 0.5 ? 3 : 4];
                } else {
                    color = petalColors[3];
                }

                const size = 2.5 + Math.random() * 1.3;
                const alpha = 220 - Math.floor(ratio * 30);
                const glow = ratio > 0.85 ? 0.5 : 0.2;
                particles.push(new Particle(px, py, color, size, alpha, glow));
            }

            // 中外层花瓣
            for (let i = 0; i < 800; i++) {
                let angle = Math.random() * Math.PI * 2;
                angle += Math.sin(angle * 5) * 0.2;
                const dist = radius * 0.5 + Math.random() * radius * 0.2;
                const px = x + dist * Math.cos(angle);
                const py = y + dist * Math.sin(angle);
                const ratio = dist / radius;

                let color;
                if (ratio > 0.6) {
                    color = petalColors[Math.random() > 0.5 ? 2 : 3];
                } else {
                    color = petalColors[Math.random() > 0.5 ? 1 : 2];
                }

                const size = 2.0 + Math.random() * 1.0;
                particles.push(new Particle(px, py, color, size, 230));
            }

            // 内层花瓣
            for (let i = 0; i < 700; i++) {
                const angle = Math.random() * Math.PI * 2;
                const dist = radius * 0.2 + Math.random() * radius * 0.3;
                const px = x + dist * Math.cos(angle);
                const py = y + dist * Math.sin(angle);
                const ratio = dist / radius;

                const color = ratio < 0.3 
                    ? petalColors[0] 
                    : petalColors[Math.random() > 0.5 ? 0 : 1];

                const size = 1.8 + Math.random() * 0.7;
                particles.push(new Particle(px, py, color, size, 240));
            }

            // 花蕊
            for (let i = 0; i < 400; i++) {
                const angle = Math.random() * Math.PI * 2;
                const dist = Math.random() * radius * 0.25;
                const px = x + dist * Math.cos(angle);
                const py = y + dist * Math.sin(angle);
                const ratio = dist / radius;

                const color = ratio < 0.3 
                    ? centerColors[0] 
                    : centerColors[Math.random() > 0.5 ? 0 : 1];

                const size = 2.2 + Math.random() * 1.0 - ratio * 1.0;
                const glow = 0.7 - ratio * 0.5;
                particles.push(new Particle(px, py, color, size, 255, glow));
            }

            return particles;
        }

        // 生成花茎和叶子
        function createStemLeaf(x, y, length) {
            const particles = [];
            const curveDir = Math.random() > 0.5 ? -1 : 1;

            // 花茎
            for (let i = 0; i < 450; i++) {
                const sy = y + Math.random() * length;
                const curve = Math.sin(sy * 0.015) * 4 * curveDir;
                const sx = x + curve + (Math.random() * 2.4 - 1.2);
                const ratio = sy / (y + length);
                const size = 1.3 + ratio * 0.7;
                
                const g = Math.floor(colors.green.stem[1] + 
                    (colors.green.leaf[1] - colors.green.stem[1]) * ratio * 0.3);
                const color = [25, g, 50];
                
                particles.push(new Particle(sx, sy, color, size, 230));
            }

            // 叶子
            const leafPositions = [
                [x - 40, y + length * 0.2, 40, -1],
                [x + 45, y + length * 0.5, 45, 1],
                [x - 30, y + length * 0.7, 35, -1]
            ];

            leafPositions.forEach(([lx, ly, size, dir]) => {
                // 叶脉
                for (let i = 0; i < 60; i++) {
                    const nx = lx + dir * Math.random() * size * 0.7;
                    const ny = ly - Math.random() * size * 0.8;
                    particles.push(new Particle(nx, ny, colors.green.stem, 1.3, 240));
                }

                // 叶片
                for (let i = 0; i < 350; i++) {
                    const angle = Math.random() * Math.PI / 1.4;
                    let dist = Math.random() * size;
                    
                    if (dist > size * 0.75) {
                        if (Math.random() > 0.6) continue;
                        dist *= 0.9 + Math.random() * 0.2;
                    }
                    
                    const px = lx + dir * dist * Math.cos(angle);
                    const py = ly - dist * Math.sin(angle);
                    const ratio = dist / size;
                    
                    const g = Math.floor(colors.green.leaf[1] + 
                        (colors.green.light[1] - colors.green.leaf[1]) * ratio);
                    const color = [40, g, 60];
                    
                    const leafSize = 1.6 + (1 - ratio) * 0.9;
                    particles.push(new Particle(px, py, color, leafSize, 210 + Math.floor(ratio * 40)));
                }
            });

            return particles;
        }

        // 生成丝带
        function createRibbon(x, y) {
            const particles = [];

            // 丝带主体
            for (let i = 0; i < 350; i++) {
                const wave1 = Math.sin(i * 0.06) * 14;
                const wave2 = Math.cos(i * 0.12) * 6;
                const x1 = x - 16 + wave1 + wave2 + (Math.random() * 3 - 1.5);
                const x2 = x + 16 + wave1 - wave2 + (Math.random() * 3 - 1.5);
                const ry = y + i * 1.0 - 45;
                const ratio = i / 350;

                const r = Math.floor(colors.ribbon.dark[0] + 
                    (colors.ribbon.light[0] - colors.ribbon.dark[0]) * ratio);
                const g = Math.floor(colors.ribbon.dark[1] + 
                    (colors.ribbon.light[1] - colors.ribbon.dark[1]) * ratio);
                const b = Math.floor(colors.ribbon.dark[2] + 
                    (colors.ribbon.light[2] - colors.ribbon.dark[2]) * ratio);
                const color = [r, g, b];

                particles.push(new Particle(x1, ry, color, 1.6, 230, 0.2));
                particles.push(new Particle(x2, ry, color, 1.6, 230, 0.2));
            }

            // 蝴蝶结
            const bowCenter = [x, y - 30];
            
            // 蝴蝶结中心
            for (let i = 0; i < 120; i++) {
                const dist = Math.random() * 14;
                const angle = Math.random() * Math.PI * 2;
                const px = bowCenter[0] + dist * Math.cos(angle);
                const py = bowCenter[1] + dist * Math.sin(angle);
                particles.push(new Particle(px, py, colors.ribbon.dark, 2.8, 240, 0.3));
            }
            
            // 蝴蝶结两侧
            [ -1, 1 ].forEach(side => {
                for (let i = 0; i < 150; i++) {
                    const angle = Math.random() * Math.PI / 2 - Math.PI / 4;
                    const dist = 12 + Math.random() * 18;
                    const px = bowCenter[0] + side * dist * Math.cos(angle);
                    const py = bowCenter[1] + dist * Math.sin(angle);
                    particles.push(new Particle(px, py, colors.ribbon.light, 2.2, 230));
                }
            });

            return particles;
        }

        // 创建花束
        function createBouquet(centerX, centerY) {
            const particles = [];
            
            // 花朵配置
            const flowers = [
                [centerX, centerY + 50, 90, [colors.rose, colors.yellow]],
                [centerX - 100, centerY + 100, 70, [colors.pink, colors.orange]],
                [centerX + 90, centerY + 90, 75, [
                    [colors.rose[1], colors.rose[2], colors.rose[3], colors.pink[2], colors.pink[3]],
                    colors.yellow
                ]],
                [centerX - 60, centerY + 150, 65, [
                    [colors.pink[1], colors.pink[2], colors.pink[3], colors.rose[3], colors.rose[4]],
                    colors.orange
                ]],
                [centerX + 65, centerY + 140, 68, [
                    [colors.rose[0], colors.rose[1], colors.rose[2], colors.pink[1], colors.pink[2]],
                    colors.yellow
                ]]
            ];

            // 添加花朵
            flowers.forEach(([x, y, r, scheme]) => {
                particles.push(...createFlower(x, y, r, scheme));
            });

            // 添加花茎和叶子
            const stemLengths = [420, 380, 400, 350, 360];
            flowers.forEach(([x, y], i) => {
                particles.push(...createStemLeaf(x, y, stemLengths[i]));
            });

            // 添加丝带
            particles.push(...createRibbon(centerX, centerY + 250));

            return particles;
        }

        // 初始化花束
        let particles = createBouquet(canvas.width / 2, canvas.height / 3);
        let time = 0;

        // 动画循环
        function animate() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            ctx.fillStyle = colors.bg;
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            time += 0.035;
            
            // 更新所有粒子
            particles.forEach(p => p.update(time));
            
            // 分层绘制
            // 1. 花茎和叶子
            particles.forEach(p => {
                if (p.color[1] > 50 && p.color[1] < 200) {
                    p.draw(ctx, scale, offsetX, offsetY);
                }
            });
            
            // 2. 花朵和丝带
            particles.forEach(p => {
                if (p.color[1] <= 50 || p.color[0] > 200) {
                    p.draw(ctx, scale, offsetX, offsetY);
                }
            });

            requestAnimationFrame(animate);
        }
        animate();

        // 事件处理 - 点击重新生成
        canvas.addEventListener('click', () => {
            particles = createBouquet(canvas.width / 2, canvas.height / 3);
        });

        // 触摸拖动处理
        canvas.addEventListener('touchstart', (e) => {
            if (e.touches.length === 1) {
                isDragging = true;
                lastTouchX = e.touches[0].clientX;
                lastTouchY = e.touches[0].clientY;
            }
        });

        canvas.addEventListener('touchmove', (e) => {
            e.preventDefault();
            if (isDragging && e.touches.length === 1) {
                const touchX = e.touches[0].clientX;
                const touchY = e.touches[0].clientY;
                offsetX += touchX - lastTouchX;
                offsetY += touchY - lastTouchY;
                lastTouchX = touchX;
                lastTouchY = touchY;
            }
        });

        canvas.addEventListener('touchend', () => {
            isDragging = false;
        });

        // 双击重置视图
        canvas.addEventListener('dblclick', () => {
            scale = 1;
            offsetX = 0;
            offsetY = 0;
        });
    </script>
</body>
</html>